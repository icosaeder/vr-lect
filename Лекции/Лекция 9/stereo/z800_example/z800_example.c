/*******************************************************************************

    Данная программа является примером использования шлема виртуальной 
    реальности eMagin z800. Она реализует алгоритм, описанный в инструкции. 
    В качестве стандарта библиотеки визуализации используется OpenGL. 
    Для упрощения кода используется библиотека GLUT, которая покрывает все 
    системные вызовы по созданию окна приложения и обработке устройств ввода 
    (клавиатуры и мыши), а также обеспечивает лёгкую межплатформенную 
    переносимость.

*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <GL/glut.h>

/**
 * Макрос перевода градусов в радианы
 */
#define PI 3.14159
#define _GradToRad(_val) ((_val) / 180.0 * PI)
/******************************************************************************/

/**
 * Глобальные переменные
 */
float cam_pos_x, cam_pos_y, cam_pos_z;
float cam_rot_x, cam_rot_y, cam_rot_z;
float d;
int doStereo;
/******************************************************************************/

/**
 * Инициализация параметров OpenGl
 */
void init()
{
    //Установка чёрного цвета фона
    glClearColor(0.0, 0.0, 0.0, 1.0);
    //Включение теста глубины
    glEnable(GL_DEPTH_TEST);
    //Включение освещения
    glEnable(GL_LIGHTING);
    //Включение нулевого источника света
    glEnable(GL_LIGHT0);
    //Установка режима плавной закраски граней
    glShadeModel(GL_SMOOTH);
    //Инициализация глобальных переменных
    cam_pos_x = cam_pos_y = cam_pos_z = 0.0;
    cam_rot_x = 60.0;
    cam_rot_y = cam_rot_z = 0.0;
    doStereo = 1;
    d = 0.05;
}
/******************************************************************************/

/**
 * Установка камеры
 * @param d -- величина смещения вдоль локальной оси Х
 */
void setCamera(float d)
{
    //Сброс матрицы преобразования
    glLoadIdentity();
    //Повороты
    glRotatef(cam_rot_x, 1.0, 0.0, 0.0);
    glRotatef(cam_rot_y, 0.0, 1.0, 0.0);
    //Перемещение с учётом смещения
    float rad = _GradToRad(cam_rot_y);
    float x = cam_pos_x + (float)cos(rad) * d;
    float y = cam_pos_y;
    float z = cam_pos_z + (float)sin(rad) * d;
    glTranslated(-x, -y, -z);
}
/******************************************************************************/

/**
 * Прорисовка сцены
 */
void drawScene()
{
    //Очистка экрана и буфера глубины
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    //Прорисовка "стоунхэнджа"
    int i;
    float a = 0.0;
    float diff[4];
    diff[0] = diff[1] = 0.8;
    diff[2] = diff[3] = 1.0;
    glMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
    for (i = 0; i < 20; ++i)
    {
        glPushMatrix();
        glTranslatef(20.0 * cos(a), 0.0, 20.0 * sin(a));
        glutSolidCube(2);
        glPopMatrix();
        a += PI / 10.0;
    }
    diff[0] = 0.93;
    diff[1] = 0.91;
    diff[2] = 0.46;
    diff[3] = 1.0;
    glMaterialfv(GL_FRONT, GL_DIFFUSE, diff);
    for (i = 0; i < 20; ++i)
    {
        glPushMatrix();
        glTranslatef(30.0 * cos(a), 0.0, 30.0 * sin(a));
        glutSolidCube(4);
        glPopMatrix();
        a += PI / 10.0;
    }
    //Смена видеобуферов
    glutSwapBuffers();
}
/******************************************************************************/

/**
 * Визуализация сцены
 */
void displayFunc()
{
    //Если режим стерео отключен, однократный рендеринг сцены, иначе -- 
    //двухкратный
    if (!doStereo)
    {
        //Установка камеры (без смещения)
        setCamera(0.0);
        //Прорисовка сцены
        drawScene();
    }
    else
    {
        //Установка камеры в позицию "левого глаза": смещение на d вдоль оси X
        setCamera(d);
        //Прорисовка сцены
        drawScene();
        //Установка камеры в позицию "правого глаза": смещение на -d вдоль оси Х
        //Примечание: смещение осуществляется на -d, так как в функции камеры 
        //матрица преобразований сбрасывается, что возвращает камеру в исходное 
        //положение. В инструкции же рассмотрен случай, когда позиция камеры 
        //сохраняется, поэтому там указана величина смещения -2d
        setCamera(-d);
        //Прорисовка сцены
        drawScene();
    }
}
/******************************************************************************/

/**
 * Изменение размеров окна
 * @param w -- ширина окна
 * @param h -- высота окна
 */
void reshapeFunc(int w, int h)
{
    //Установка порта просмотра
    glViewport(0, 0, w, h);
    //Установка перспективной проекции
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (float)w / (float)h, 1.0, 1000.0);
    glMatrixMode(GL_MODELVIEW);
}
/******************************************************************************/

/**
 * Обработка мыши
 * @param x -- х-координата курсора
 * @param y -- y-координата курсора
 */
void mouseFunc(int x, int y)
{
    static int oldX = 0, oldY = 0;
    //Изменение угла поворота камеры относительно изменения пложения курсора
    //(мышь управляет камерой)
    cam_rot_x += (float)(y - oldY);
    cam_rot_y += (float)(x - oldX);
    //Запоминание текущего положения
    oldX = x;
    oldY = y;
}
/******************************************************************************/

/**
 * Обработка клавиатуры
 * @param key -- код нажатой клавиши
 * @param x -- x-координата курсора мыши в момент нажатия клавиши
 * @param y -- y-координата курсора мыши в момент нажатия клавиши
 */
void keyboardFunc(unsigned char key, int x, int y)
{
    static int kSign = 0;
    //Клавиши WSDA управляют перемещение камеры
    float rad_x = _GradToRad(cam_rot_x);
    float rad_y = _GradToRad(cam_rot_y);
    if (key == 'w')
    {
        cam_pos_x += (float)sin(rad_y);
        cam_pos_y -= (float)sin(rad_x);
        cam_pos_z -= (float)cos(rad_y);
        kSign = 0;
    }
    if (key == 's')
    {
        cam_pos_x -= (float)sin(rad_y);
        cam_pos_y += (float)sin(rad_x);
        cam_pos_z += (float)cos(rad_y);
        kSign = 0;
    }
    if (key == 'd')
    {
        cam_pos_x += (float)cos(rad_y);
        cam_pos_z += (float)sin(rad_y);
        kSign = 0;
    }
    if (key == 'a')
    {
        cam_pos_x -= (float)cos(rad_y);
        cam_pos_z -= (float)sin(rad_y);
        kSign = 0;
    }
    //Клавиша T включает и выключает стереорежим
    if (key == 't' && !kSign)
    {
        doStereo = !doStereo;
        kSign = 1;
    }
    //Клавиши 1 и 2 изменяют величину разделения стереопары
    if (key == '1')
    {
        d -= 0.01;
        kSign = 0;
    }
    if (key == '2')
    {
        d += 0.01;
        kSign = 0;
    }
    //Клавиша Q меняет глаза местами
    if (key == 'q' && !kSign)
    {
        d = -d;
        kSign = 1;
    }
    //Клавиша ESC завершает программу
    if (key == 27)
        exit(0);
}
/******************************************************************************/

/**
 * Основная функция -- точка входа в программу
 */
int main(int argc, char **argv)
{
    //Инициализация GLUT
    glutInit(&argc, argv);
    //Установка режима окна приложения на двойную буферизацию и наличие буфера 
    //глубины
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH);
    //Перевод программы в полноэкранный режим с разрешением 800х600, 
    //глубиной цвета 32 бита и частотой обновления экрана 60 Гц
    glutGameModeString("800x600:32@60");
    glutEnterGameMode();
    //Установка обработчика на событие перерисовки окна
    glutDisplayFunc(displayFunc);
    glutIdleFunc(displayFunc);
    //Установка обработчика на событие изменение размеров окна
    glutReshapeFunc(reshapeFunc);
    //Установка обработчика на событие перемещения мыши
    glutPassiveMotionFunc(mouseFunc);
    //Установка обработчика на событие ввода с клавиатуры
    glutKeyboardFunc(keyboardFunc);
    //Инициализация параметров OpenGL
    init();
    //Запуск основного цикла визуализации
    glutMainLoop();
    return 0;
}
/******************************************************************************/
/******************************************************************************/

